---
layout: post
title: "Undoing the programmer in me"
description: Five steps in my cookbook to become the better entrepreneur
headline: Undoing the programmer in me
modified: 2016-05-01
category: personal
tags: [Personal,Entrepreneur]
image: 
  feature: 
comments: true
share: true
mathjax:
published: true
featured: true
---

How hard is it for a programmer to become an entrepreneur. Actually not much. But how hard is it to be an excellent one? Apparently a lot. In the process of pushing myself to be the next better me, I found some interesting points that blocked me from being experimental and entrepreneurial at times. Here’s my handbook list on five major pain points and how I fixed them. 

## Develop systems with less features
How many times did you build a system with features that are never used? If you developed a login system with a powerful backend, sure it deserves a slow mo clap but from the end user view (who just wants to click on one button) it doesn't matter.

**Personal example:** I built a keyboard app with a very good system and awesome set of features. The idea is lost in wheel of time since I was never happy enough to ship it. There was always that next set of features that should be in the build. 

**Solved it:** List down the user facing features for the system. List the top X features (X=1 as much as possible) that you can’t live without. Ship it with that feature and iterate.

## Don’t future proof
Programmers have OCD (may be not in terms of lifestyle) regarding the projects. 

**Personal example:** When I developed a dating app with a vision to change the dating industry (which I still think has insane potential and challenges), I thought about all possible ways of 

* 	using the app
*	making it secure
*	reusing the system

I created the pipeline which covered all above aspects and obviously it was lengthier. (richer too. agree) But I personally think it didn’t matter. The first break in Ola’s product happened months after the traction. If they sat with building a complete secure app, I don't think Ola would have been where it is right now.

**Solved it:** Being a developer, you cannot not think about future proofing. If there’s anyone who does that. its you. Think about future proofing. But stop there. Keep that in the back of your mind (I meant, TODO’s and FIXME’s) and consciously don't work on it.

## Understand the time graph
Unfortunately none of us are time-lords*. The biggest asset we have is time. So have time-to-user graph in mind. Always. First step in understanding the time graph is to build one. Ask your self these questions, What is the rate of new users per day/week/month for last two days/weeks/months your product has. Plot em up in a virtual graph in your mind and extrapolate to next day/week/month. It will be a straight line. This is what happens when the product (I meant marketing, tech, sales, ops every aspect of it) stays as it is and you don't bring a big change in the product. Obviously this is unsustainable. Once you see this, think about the next feature you are deploying. Every day the feature is delayed for any reason (including other reasons we discussed), you lost X users who could've at the very least helped you in making the feature better (and on the very positive front, might have converted because of that).

## Experiment every step
This is pretty straightforward from time-graph analysis. But worth mentioning separately given the value we can extract out of it. The best way to implement a feature and make it the best is to get in the loop of launch-data-iterate. The first step is to launch it as soon as possible with a plan to collect the data for iteration. A successful product/feature launch without a plan to collect data is not a successful product/feature. Analyse the data and let your users surprise you. Now iterate. Half of the time that goes into having discussions (especially design discussions) can be avoided with this. There is only person who has answer to all subjective design decisions. You end user. Employ him for that and put your time to better use. 

## 10000 hours
I remember my friend mentioning that one needs 10000 hours to work in one domain to become a pro in it. Roughly translates to 3-5 years depending on how much time/day you are working on it. Kinda makes sense. But for a product development, you don't have 3-5 years of research time. So mimic this with available resources. If you want to implement a chat system. List down the primary set of features that you need without future proofing. Use a third party client and collect data points. Experiment as much as possible and let your user’s tell you what exactly they need. Now you have the power of data (to mimic the knowledge of 10000 hours) to build a standalone system.